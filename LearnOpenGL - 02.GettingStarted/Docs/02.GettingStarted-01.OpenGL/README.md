# [Getting Started : OpenGL](https://learnopengl.com/Getting-started/OpenGL)

여행을 시작하기 전에, 우선 OpenGL이 정확히 무엇인지를 정의해야 합니다. OpenGL은 주로 우리에게 그래픽과 이미지를 다루기 위해 사용할 수 있는 다양한 함수 집합을 제공하는 API(응용 프로그래밍 인터페이스)로 간주됩니다. 그러나 OpenGL 자체는 API가 아닌 명세서에 불과하며, Khronos 그룹에 의해 개발되고 유지되고 있습니다.


OpenGL 명세는 각 함수의 결과 및 동작 방식을 정확하게 명시합니다. 그런 다음 이 명세를 구현하는 개발자들은 해당 함수의 동작 방식에 대한 해결책을 마련하는 것이 됩니다. OpenGL 명세는 구현 세부 정보를 제공하지 않기 때문에, 실제 개발된 OpenGL 버전은 명세와 일치하는 결과를 제공한다면(따라서 사용자에게는 동일한 결과를 제공한다면), 서로 다른 구현을 가질 수 있습니다.


실제 OpenGL 라이브러리를 개발하는 사람들은 일반적으로 그래픽 카드 제조업체입니다. 구매한 그래픽 카드는 해당 카드(시리즈)에 특별히 개발된 OpenGL 버전을 지원합니다. Apple 시스템을 사용할 때는 OpenGL 라이브러리가 Apple 자체에서 유지보수되며, Linux에서는 그래픽 공급업체의 버전과 이러한 라이브러리의 업데이트를 담당하는 취미 개발자들의 조합이 존재합니다. 이는 또한 OpenGL이 예상치 못한 이상 동작을 보일 때, 이는 대부분 그래픽 카드 제조업체(또는 해당 라이브러리를 개발/유지보수하는 사람)의 잘못일 가능성이 높다는 것을 의미합니다.


> 대부분의 구현은 그래픽 카드 제조업체에 의해 개발되므로, 구현에서 버그가 발생할 경우 일반적으로 비디오 카드 드라이버를 업데이트하여 해결할 수 있습니다. 이 드라이버에는 해당 카드가 지원하는 최신 OpenGL 버전이 포함되어 있습니다. 이것은 그래픽 드라이버를 가끔씩 업데이트하는 것이 권장되는 이유 중 하나입니다.


Khronos는 모든 OpenGL 버전에 대한 명세 문서를 공개적으로 호스팅합니다. 관심 있는 독자는 여기에서 버전 3.3의 OpenGL 명세를 찾을 수 있습니다(우리가 사용할 버전입니다). OpenGL의 세부 사항을 탐구하려는 경우, 이 문서는 읽을 가치가 있습니다(구현보다는 주로 결과를 설명하는 점에 유의하세요). 명세는 또한 함수의 정확한 동작 방식을 찾는 데 큰 참고 자료가 됩니다.
<br><br>


## Core-profile vs Immediate mode

옛날에는 OpenGL을 사용하면서 그래픽을 그리기 위해 즉시 모드(고정 함수 파이프라인이라고도 함)에서 개발하는 것을 의미했습니다. 이는 그래픽을 그리는 데 사용하기 쉬운 방법으로, OpenGL의 대부분의 기능이 라이브러리 안에 숨겨져 있었고, 개발자들은 OpenGL이 계산을 어떻게 수행하는지에 대해 크게 제어할 수 없었습니다. 그러나 개발자들은 점점 더 유연성을 원하게 되었고, 결과적으로 명세는 더 유연해지기 시작했습니다. 개발자들은 그래픽에 대해 더 많은 제어권을 얻게 되었습니다. 즉시 모드는 사용하기 쉽고 이해하기 쉽지만, 극도로 비효율적입니다. 이러한 이유로 명세는 버전 3.2부터 즉시 모드 기능을 폐기하기 시작하고, 개발자들에게 OpenGL의 코어 프로파일 모드에서 개발하도록 유도하기 시작했습니다. 코어 프로파일 모드는 OpenGL 명세의 일부로, 모든 이전에 폐기된 기능을 제거한 것입니다.


OpenGL의 코어 프로파일을 사용할 때는, OpenGL은 우리가 현대적인 방법을 사용하도록 강제합니다. OpenGL의 폐기된 함수 중 하나를 사용하려고 하면, OpenGL은 오류를 발생시키고 그리기를 중단합니다. 현대적인 방법을 배우는 장점은 매우 유연하고 효율적이라는 점입니다. 그러나 학습이 어렵기도 합니다. 즉시 모드는 OpenGL이 수행하는 실제 작업으로부터 많이 추상화되어 있으며, 쉽게 배울 수 있지만 OpenGL이 실제로 어떻게 동작하는지 이해하기 어렵습니다. 현대적인 방법은 개발자가 OpenGL과 그래픽 프로그래밍을 실제로 이해해야 한다는 점을 요구하며, 조금 어려울 수 있지만 훨씬 더 유연성과 효율성을 제공하며, 가장 중요한 것은 그래픽 프로그래밍에 대한 훨씬 더 좋은 이해를 가능하게 합니다.


그래서 이 책이 코어 프로파일 OpenGL 버전 3.3을 대상으로 하는 이유입니다. 비록 어렵지만, 그 노력은 크게 가치가 있는 것입니다.


오늘날에는 더 높은 버전의 OpenGL(글을 작성하는 시점에서는 4.6)이 선택 가능합니다. 그럼에도 불구하고 왜 OpenGL 3.3을 배워야 하는가요? 이 질문에 대한 답은 상대적으로 간단합니다. OpenGL 3.3부터 시작되는 모든 이후 버전은 OpenGL에 유용한 추가 기능을 제공하지만, OpenGL의 핵심 메커니즘은 변경되지 않습니다. 새로운 버전은 동일한 작업을 수행하는 더 효율적이거나 유용한 방법을 약간 더 소개할 뿐입니다. 그 결과, 모든 개념과 기술은 현대적인 OpenGL 버전 전체에 걸쳐 동일하게 유지되므로 OpenGL 3.3을 배우는 것이 완벽히 유효합니다. 준비가 되었을 때나 더 많은 경험을 쌓았을 때, 쉽게 최신 OpenGL 버전에서 특정 기능을 사용할 수 있습니다.


> 최신 버전의 OpenGL 기능을 사용할 때에는 가장 최신의 그래픽 카드만이 애플리케이션을 실행할 수 있습니다. 이것이 대부분의 개발자들이 일반적으로 더 낮은 OpenGL 버전을 대상으로 하고 선택적으로 더 높은 버전 기능을 활성화하는 이유입니다.


일부 장(chapter)에서는 더 현대적인 기능들을 찾을 수 있으며, 해당 기능들은 명시적으로 표기되어 있을 것입니다.
<br><br>


## Extensions

OpenGL의 큰 장점 중 하나는 확장(extension)의 지원입니다. 그래픽 회사가 새로운 기술이나 렌더링을 위한 새로운 큰 최적화를 개발할 때, 이는 종종 드라이버에 구현된 확장(extension)으로 나타납니다. 애플리케이션이 실행되는 하드웨어가 해당 확장을 지원하는 경우, 개발자는 확장에서 제공하는 기능을 사용하여 고급 또는 효율적인 그래픽을 구현할 수 있습니다. 이렇게 함으로써 그래픽 개발자는 OpenGL이 향후 버전에 해당 기능을 포함시킬 때까지 기다릴 필요 없이 새로운 렌더링 기법을 사용할 수 있습니다. 단순히 그래픽 카드가 해당 확장을 지원하는지 확인함으로써 가능합니다. 종종 확장(extension)이 인기 있거나 매우 유용한 경우, 이후의 OpenGL 버전에 포함되기도 합니다.


개발자는 사용하기 전에 이러한 확장(extension) 중 어떤 것들이 사용 가능한지 쿼리해야 합니다(또는 OpenGL 확장 라이브러리를 사용할 수도 있습니다). 이를 통해 개발자는 확장의 사용 가능 여부에 따라 더 나은 또는 더 효율적인 작업을 수행할 수 있습니다.


```
if(GL_ARB_extension_name)
{
    // Do cool new and modern stuff supported by hardware
}
else
{
    // Extension not supported: do it the old way
}
```

OpenGL 3.3 버전에서는 대부분의 기법에 대해 확장(extension)을 거의 필요로하지 않지만, 필요한 경우 적절한 지침이 제공됩니다.
<br><br>


## State machine

OpenGL 자체는 큰 상태 기계(state machine)입니다. OpenGL이 현재 어떻게 동작해야 하는지 정의하는 변수들의 모음입니다. OpenGL의 상태는 일반적으로 OpenGL 컨텍스트로 알려져 있습니다. OpenGL을 사용할 때, 우리는 종종 옵션을 설정하고 버퍼를 조작한 다음 현재 컨텍스트를 사용하여 렌더링하는 것과 같은 방식으로 상태를 변경합니다.


예를 들어 삼각형 대신 선을 그리고자 할 때, 우리는 OpenGL에게 그리는 방식을 설정하는 몇 가지 컨텍스트 변수를 변경하여 OpenGL의 상태를 변경합니다. OpenGL에 선을 그리도록 컨텍스트를 변경하면, 다음 그리기 명령은 이제 선을 그리는 대신 삼각형을 그립니다.


OpenGL 작업 중에는 컨텍스트를 변경하는 여러 상태 변경 함수와 현재 OpenGL 상태에 기반한 몇 가지 작업을 수행하는 상태 사용 함수가 있습니다. OpenGL이 기본적으로 하나의 큰 상태 기계임을 명심한다면, 대부분의 기능이 더욱 명확해질 것입니다.
<br><Br>


## Objects

OpenGL 라이브러리는 C로 작성되었으며 다른 언어로의 많은 파생이 가능하지만, 핵심은 여전히 C 라이브러리입니다. C의 언어 구조 중 많은 부분은 다른 고급 레벨 언어로의 번역이 그렇게 잘 되지 않기 때문에, OpenGL은 여러 가지 추상화를 고려하여 개발되었습니다. 이 추상화 중 하나가 OpenGL의 객체(objects)입니다.


OpenGL의 객체는 OpenGL 상태의 하위 집합을 나타내는 옵션들의 모음입니다. 예를 들어, 그리기 창의 설정을 나타내는 객체를 가질 수 있습니다. 이후에 해당 객체의 크기, 지원하는 색상 수 등을 설정할 수 있습니다. 객체는 C 구조체와 유사하게 시각화할 수 있습니다.
```
struct object_name {
    float  option1;
    int    option2;
    char[] name;
};
```


일반적으로 객체를 사용하려면 다음과 같은 방식으로 진행됩니다 (OpenGL의 컨텍스트는 대형 구조체로 시각화됩니다):
```
// The State of OpenGL
struct OpenGL_Context {
  	...
  	object_name* object_Window_Target;
  	...  	
};


// create object
unsigned int objectId = 0;
glGenObject(1, &objectId);
// bind/assign object to context
glBindObject(GL_WINDOW_TARGET, objectId);
// set options of object currently bound to GL_WINDOW_TARGET
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// set context target back to default
glBindObject(GL_WINDOW_TARGET, 0);
```


이 작은 코드 조각은 OpenGL을 사용할 때 자주 볼 수 있는 작업 흐름입니다. 먼저 객체를 생성하고, 실제 객체 데이터는 내부적으로 저장되며, 참조를 위해 해당 객체의 ID를 저장합니다. 그런 다음, 객체를 (ID를 사용하여) 컨텍스트의 대상 위치에 바인딩합니다 (예시 창 객체 대상의 위치는 GL_WINDOW_TARGET로 정의됩니다). 그 다음 창 옵션을 설정하고, 마지막으로 현재 객체 ID를 0으로 설정하여 객체의 바인딩을 해제합니다. 설정한 옵션은 objectId로 참조되는 객체에 저장되며, 객체를 다시 GL_WINDOW_TARGET에 바인딩할 때 복원됩니다.


> 지금까지 제공된 코드 예제는 OpenGL이 작동하는 방식을 대략적으로 보여주는 것뿐입니다. 이 책을 통해 실제 예제를 충분히 접하게 될 것입니다.


이러한 객체를 사용하는 큰 장점은 응용 프로그램에서 하나 이상의 객체를 정의하고 옵션을 설정할 수 있으며, OpenGL 상태를 사용하는 작업을 시작할 때 우리가 선호하는 설정과 함께 객체를 바인딩할 수 있다는 것입니다. 예를 들어, 3D 모델 데이터 (집이나 캐릭터와 같은)를 포함하는 컨테이너 객체로 동작하는 객체들이 있을 수 있습니다. 우리가 그 중 하나를 그리고 싶을 때는 그리고자 하는 모델 데이터를 포함하는 객체를 바인딩합니다 (우리는 먼저 이러한 객체들을 생성하고 옵션을 설정합니다). 여러 개의 객체를 가지면 많은 모델을 지정할 수 있으며, 특정 모델을 그리고자 할 때는 해당 객체를 그리기 전에 간단히 바인딩하기만 하면 되므로 모든 옵션을 다시 설정할 필요가 없습니다.
<br><br>


## Let's get started

이제 OpenGL이라는 사양과 라이브러리에 대해 약간 배웠으며, OpenGL이 대략적으로 어떻게 작동하는지와 OpenGL이 사용하는 몇 가지 사용자 정의 트릭을 알게 되었습니다. 모든 것을 완전히 이해하지 못했다면 걱정하지 마세요. 이 책을 통해 각 단계를 따라가며 충분한 예제를 통해 OpenGL을 실제로 이해할 수 있을 것입니다.